%% ############ MULTIAGENT TRANSPORTATION PORJECT: 2025.08.28 #############
%% Main File for MPC (Contains MPC Loop)

clc; clear; close all
addpath('C:\Users\jinwo\OneDrive\바탕 화면\LARR\Program_Files\casadi-3.7.0-windows64-matlab2018b')
import casadi.*

% Structure used to time task
timeReport.mapProcessing_signedDist=[];
timeReport.mapProcessing_symbolic=[];
timeReport.rrtStarPlannerBuild=[];
timeReport.pathPlannerBuild=[];
timeReport.nppSolverBuild=[];
timeReport.trajGen_inLoops=[];
timeReport.contGen_inLoops=[];

% -------------------------------------------------------------------------
% Map Selection
% multi_mpc_map1.m : MATLAB simpleMap
% multi_mpc_map2.m : MATLAB complexMap
% multi_mpc_map3.m : Custom L-corridor map
% multi_mpc_map4.m : IsaacSim Hospital map

selectMap=4;
% -------------------------------------------------------------------------

% -------------------------------------------------------------------------
% Planner Selection
% Planner 1: RRT Planner
% Planner 2: RRT* Planner
% Planner 3: PRM Planner

selectPlanner=3;
% -------------------------------------------------------------------------

%% 1. Calling Parameters and User Defined Values
run('multi_mpc_params.m')

%% 2. Map Selection and Occupancy Matrix Generation

disp("Occupancy matrix being generated...")

if selectMap==1
    run('multi_mpc_map1.m')
elseif selectMap==2
    run('multi_mpc_map2.m')
elseif selectMap==3
    run('multi_mpc_map3.m')
else
    run('multi_mpc_map4.m')
end

%% 3. Generation of Binary Occupancy Maps and etc.
disp("Map related objects being generated...")
run('multi_mpc_mapProcessing.m')

%% 4. Construction of the Selected Path Planner
disp("Path planner being generated...")

if selectPlanner==1
    run('multi_mpc_path_rrt.m')
elseif selectPlanner==2
    run('multi_mpc_path_rrtStar.m')
else
    run('multi_mpc_path_prm.m')
end


%% 5. Construction of the Nonliear Programming Problem (NPP) Solver
run('multi_mpc_npp.m')

%% 6. The MPC Loops

% Structure to store MPC results
mpc_results.state=[user.pose_init(1); user.pose_init(2); user.pose_init(3);...
    user.pose_init(3)*ones(params.sys.n_rbt, 1)];   % User defined initial pose set as initial state
mpc_results.up=[];
mpc_results.u=[];
mpc_results.f_val=[];
mpc_results.g_val=[];
mpc_results.used_ref=[];      % Stores reference pose values used in the MPC
mpc_results.candidate_ref={}; % Stores all N reference pose values used in the MPC, in cell form
mpc_results.waypoints_ref={}; % Stores waypoints generated by the path planner, in cell form
mpc_results.minSignedDist=[]; % Stores time history of the assembly's minimum signed distances

% The MPC Loop
mpc_iter=0;   % MPC Loop Number
while ~mpcTermination(mpc_results.state(:, end), user)
    tic;   % Start timer for trajectory generation

    % ---------------------------------------------------------------------
    % 1. Reference Trajectory Generation Based on Current Position
    if selectPlanner==1
        [pathObject, solInfo]=plan(rrtPlanner, mpc_results.state(1:3, end)', user.pose_fnal(1:3)');
        wpts=pathObject.States(:, 1:2)';   % Made waypoints
        if ~solInfo.IsPathFound
            disp("RRT planner failed to find path")
        end
        
    elseif selectPlanner==2
        [pathObject, solInfo]=plan(rrtStarPlanner, mpc_results.state(1:3, end)', user.pose_fnal(1:3)');
        wpts=pathObject.States(:, 1:2)';   % Made waypoints
        if ~solInfo.IsPathFound
            disp("RRT* planner failed to find path")
        end
    else
        path=findpath(prmPlanner, mpc_results.state(1:2, end)', user.pose_fnal(1:2)');
        if length(path(:, 1))>=3
            if (path(3, :)-path(2, :))*(path(3, :)-path(2, :))'>=params.con.prmFactor^2*(path(3, :)-path(1, :))*(path(3, :)-path(1, :))'
                wpts=[path(1, :)', path(3:end, :)'];
            else
                wpts=path';
            end
        else
            wpts=path';
        end

        %wpts=path';   % FOR TESTING!
    end

    [ref.x, ref.y]=ReferenceFromWaypoints(wpts, user, params);

    % NOTE: Using reference orientation as averaged tangent directions yield better results
    temp=zeros(1, length(ref.x));
    for i=1:length(ref.x)-1
        temp(i)=atan2(ref.y(i+1)-ref.y(i), ref.x(i+1)-ref.x(i));
    end
    ref.theta=temp(1)*ones(1, length(ref.x));
    %ref.theta=atan2(ref.y(end)-ref.y(1), ref.x(end)-ref.x(1))*ones(1, length(ref.x));

    ref.col_form=zeros(3*N, 1);   % Modify in column form to update in npp.p
    for i=1:N
        ref.col_form(3*(i-1)+1)=ref.x(i);
        ref.col_form(3*(i-1)+2)=ref.y(i);
        ref.col_form(3*(i-1)+3)=ref.theta(i);
    end
    % ---------------------------------------------------------------------

    timeReport.trajGen_inLoops=[timeReport.trajGen_inLoops, toc];  % End timer for trajectory generation

    tic;   % Start timer for NPP solution

    % ---------------------------------------------------------------------
    % 2. Initial "guesses" for the NPP Solution
    if mpc_iter==0   % Initial loop requires manual cold setting
        % Initial guesses based on experience
        init_X=repmat(mpc_results.state(:, 1), N+1, 1);
        init_Up=repmat([mpc_results.state(1, 1); mpc_results.state(2, 1); 1e-3;...
        zeros(params.sys.n_rbt, 1)], N, 1); % NOTE of warning: omegaM should never start at zero!
        init_U=repmat([0; 0], N*params.sys.n_rbt, 1);

        x0_values=[init_X; init_Up; init_U];
    else   % Later loop utilizes previous solutions as warm start guesses
        x0_values=full(results.x);
        lam_x0_values=full(results.lam_x);
        lam_g0_values=full(results.lam_g);
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 3. Setting Parameter Values
    % Note: npp.p structure
    % npp.p=["Current state"; "Desired Cart Poses"; "Last Used Controls"]
    P_values=zeros(length(npp.p), 1);

    P_values(1:lgth.P_X_curr_col)=mpc_results.state(:, end);  % Current state
    temp=lgth.P_X_curr_col;
    P_values(temp+1:temp+lgth.P_Xb_desr_col)=ref.col_form;    % Desired cart poses 
    temp=temp+lgth.P_Xb_desr_col;
    if mpc_iter==0
        P_values(temp+1:temp+lgth.P_U_last_col)=zeros(lgth.P_U_last_col, 1);
        % Controls considered to be zero initially
    else
        P_values(temp+1:temp+lgth.P_U_last_col)=mpc_results.u(:, end);   % Last used controls
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 4. Solution of the NPP
    if mpc_iter==0   % Initial cold start solver
        results=npp_solver_init('x0', x0_values, 'p', P_values,...
            'lbx', lbx_arr, 'ubx', ubx_arr, 'lbg', lbg_arr, 'ubg', ubg_arr);
    else   % Warm start solver
        results=npp_solver_warm('x0', x0_values, 'lam_x0', lam_x0_values, 'lam_g0', lam_g0_values, 'p', P_values,...
            'lbx', lbx_arr, 'ubx', ubx_arr, 'lbg', lbg_arr, 'ubg', ubg_arr);
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 5. Storage of Results
    mpc_results.state=...
        [mpc_results.state, full(results.x((3+M)+1:2*(3+M)))];   % State
    temp=lgth.X_col;
    mpc_results.up=...
        [mpc_results.up, full(results.x(temp+1:temp+3+M))];   % Pseudoinputs
    temp=temp+lgth.Up_col;
    mpc_results.u=...
        [mpc_results.u, full(results.x(temp+1:temp+2*M))];   % Actual Inputs
    mpc_results.f_val=[mpc_results.f_val, full(results.f)];
    mpc_results.g_val=[mpc_results.g_val, full(results.g)];
    mpc_results.used_ref=[mpc_results.used_ref, [ref.x(1); ref.y(1); ref.theta(1)]];
    mpc_results.candidate_ref=[mpc_results.candidate_ref, {[ref.x; ref.y; ref.theta]}];
    mpc_results.waypoints_ref=[mpc_results.waypoints_ref, {wpts}];
    mpc_results.minSignedDist=[mpc_results.minSignedDist, full(results.g(end-N+1))];
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 6. Display and Miscellaneous

    mpc_iter=mpc_iter+1;
    disp("MPC Loop Number")
    disp(mpc_iter)
    disp("Current Pose of B")
    disp(mpc_results.state(1:3, end))

    timeReport.contGen_inLoops=[timeReport.contGen_inLoops, toc];   % End NPP solution timer

    if mpc_iter>=2000
        break
    end
    % ---------------------------------------------------------------------
end

%% 7. Post Processing of Data
run('multi_mpc_robots.m')

%% 8. Presentation of Results
run('multi_mpc_showresults');

%% Functions

% Function for MPC Termination Conditions
function results=mpcTermination(x, user)

if norm(x(1:2)-user.pose_fnal(1:2))<0.5 && abs(x(3)-user.pose_fnal(3))<Inf
    results=true;   % Terminate if true
else
    results=false;
end

end

% Function for Generating Reference States from Planner Waypoints
function [x_ref, y_ref]=ReferenceFromWaypoints(wpts, user, params)
% NOTE: wpts is a matrix of structure [x1 x2 x3 ... xn; y1 y2 y3 ... yn]

% Positions are produced by fitting cubic polynomials
    
n_pts=100;
tpts=0:length(wpts(1, :))-1;
t_samples=tpts(1):1/(n_pts-1):tpts(end);

[pose, ~, ~, ~]=cubicpolytraj(wpts, tpts, t_samples);
    
% Selecting Reference Points to Return
dist=zeros(1, length(pose(1, :)));
for i=2:length(dist)
    dist(i)=dist(i-1)+norm(pose(1:2, i)-pose(1:2, i-1));   % Accumulated distance
end

ref_pose=[];
i=1;
while true
    if dist(i)>=user.ref_spdd*params.con.t_delta
        temp=ref_pose;
        ref_pose=[temp, pose(:, i)];   % Store in ref_posi
        dist=dist-user.ref_spdd*params.con.t_delta*ones(1, length(dist));   % Reset dist
    end

    if i>=length(dist)
        temp=ref_pose;
        ref_pose=[temp, pose(:, end)];   % End point, i.e. user defined final position stored repeatedly
    end

    if isempty(ref_pose)==false && length(ref_pose(1, :))>=params.con.n_hor
        break
    end

    % Index update logic
    if i<length(dist)
        i=i+1;
    end
end

x_ref=ref_pose(1, :);       % Function output
y_ref=ref_pose(2, :);       % Function output

end
