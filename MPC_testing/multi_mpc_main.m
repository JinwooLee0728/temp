%% ############ MULTIAGENT TRANSPORTATION PORJECT: 2025.08.28 #############
%% Main File for MPC (Contains MPC Loop)

clc; clear; close all
addpath('C:\Users\jinwo\OneDrive\바탕 화면\LARR\Program_Files\casadi-3.7.0-windows64-matlab2018b')
import casadi.*

% Structure used to time task
timeReport.mapProcessing_signedDist=[];
timeReport.mapProcessing_symbolic=[];
timeReport.mapProcessing_graphgen=[];
timeReport.rrtStarPlannerBuild=[];
timeReport.pathPlannerBuild=[];
timeReport.nppSolverBuild=[];
timeReport.trajGen_inLoops=[];
timeReport.contGen_inLoops=[];

%% 1. Calling Parameters and User Defined Values
run('multi_mpc_params.m')

%% 2. Map Selection and Occupancy Matrix Generation

fprintf("Occupancy matrix being generated...\n\n")

run("multi_mpc_map_blank.m")

%% 3. Generation of Binary Occupancy Maps and etc.

run('multi_mpc_mapProcessing.m')

%% 4. Construction of the Nonliear Programming Problem (NPP) Solver

run('multi_mpc_npp.m')

%% 5. The MPC Loops

% Structure to store MPC results
mpc_results.state=[user.pose_init(1); user.pose_init(2); user.pose_init(3);...
    user.robotOrientation_init];   % User defined initial pose set as initial state
mpc_results.up=[];
mpc_results.u=[];
mpc_results.f_val=[];
mpc_results.g_val=[];
mpc_results.used_ref=[];      % Stores reference pose values used in the MPC
mpc_results.candidate_ref={}; % Stores all N reference pose values used in the MPC, in cell form
mpc_results.waypoints_ref={}; % Stores waypoints generated by the path planner, in cell form
mpc_results.minSignedDist=[]; % Stores time history of the assembly's minimum signed distances

% The MPC Loop
mpc_iter=0;   % MPC Loop Number
while ~mpcTermination(mpc_results.state(:, end), user)

    % ---------------------------------------------------------------------
    % 1. Reference trajectory generation

    ref.x=zeros(1, N);
    ref.y=zeros(1, N);
    ref.theta=zeros(1, N);
    for i=1:N
        ref.x(i)=2.5;
        ref.y(i)=+1.5;
        ref.theta(i)=deg2rad(+90);
    end

    % NOTE: N reference poses sampled here anyway!
    ref.col_form=zeros(3*N, 1);   % Modify in column form to update in npp.p
    for i=1:N
        ref.col_form(3*(i-1)+1)=ref.x(i);
        ref.col_form(3*(i-1)+2)=ref.y(i);
        ref.col_form(3*(i-1)+3)=ref.theta(i);
    end
    % ---------------------------------------------------------------------

    timeReport.trajGen_inLoops=[timeReport.trajGen_inLoops, toc];  % End timer for trajectory generation

    tic;   % Start timer for NPP solution

    % ---------------------------------------------------------------------
    % 2. Initial "guesses" for the NPP Solution
    if mpc_iter==0   % Initial loop requires manual cold setting
        % Initial guesses based on experience
        init_X=repmat(mpc_results.state(:, 1), N+1, 1);
        init_Up=repmat([mpc_results.state(1, 1); mpc_results.state(2, 1); 1e-3;...
        zeros(params.sys.n_rbt, 1)], N, 1); % NOTE of warning: omegaM should never start at zero!
        init_U=repmat([0; 0], N*params.sys.n_rbt, 1);

        x0_values=[init_X; init_Up; init_U];
    else   % Later loop utilizes previous solutions as warm start guesses
        x0_values=full(results.x);
        lam_x0_values=full(results.lam_x);
        lam_g0_values=full(results.lam_g);
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 3. Setting Parameter Values
    % Note: npp.p structure
    % npp.p=["Current state"; "Desired Cart Poses"; "Last Used Controls"]
    P_values=zeros(length(npp.p), 1);

    P_values(1:lgth.P_X_curr_col)=mpc_results.state(:, end);  % Current state
    temp=lgth.P_X_curr_col;
    P_values(temp+1:temp+lgth.P_Xb_desr_col)=ref.col_form;    % Desired cart poses 
    temp=temp+lgth.P_Xb_desr_col;
    if mpc_iter==0
        P_values(temp+1:temp+lgth.P_U_last_col)=zeros(lgth.P_U_last_col, 1);
        % Controls considered to be zero initially
    else
        P_values(temp+1:temp+lgth.P_U_last_col)=mpc_results.u(:, end);   % Last used controls
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 4. Solution of the NPP
    if mpc_iter==0   % Initial cold start solver
        results=npp_solver_init('x0', x0_values, 'p', P_values,...
            'lbx', lbx_arr, 'ubx', ubx_arr, 'lbg', lbg_arr, 'ubg', ubg_arr);
    else   % Warm start solver
        results=npp_solver_warm('x0', x0_values, 'lam_x0', lam_x0_values, 'lam_g0', lam_g0_values, 'p', P_values,...
            'lbx', lbx_arr, 'ubx', ubx_arr, 'lbg', lbg_arr, 'ubg', ubg_arr);
    end
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 5. Storage of Results
    mpc_results.state=...
        [mpc_results.state, full(results.x((3+M)+1:2*(3+M)))];   % State
    temp=lgth.X_col;
    mpc_results.up=...
        [mpc_results.up, full(results.x(temp+1:temp+3+M))];   % Pseudoinputs
    temp=temp+lgth.Up_col;
    mpc_results.u=...
        [mpc_results.u, full(results.x(temp+1:temp+2*M))];   % Actual Inputs
    mpc_results.f_val=[mpc_results.f_val, full(results.f)];
    mpc_results.g_val=[mpc_results.g_val, full(results.g)];
    mpc_results.used_ref=[mpc_results.used_ref, [ref.x(1); ref.y(1); ref.theta(1)]];
    mpc_results.candidate_ref=[mpc_results.candidate_ref, {[ref.x; ref.y; ref.theta]}];
    mpc_results.minSignedDist=[mpc_results.minSignedDist, full(results.g(end-N+1))];
    % ---------------------------------------------------------------------

    % ---------------------------------------------------------------------
    % 6. Display and Miscellaneous

    mpc_iter=mpc_iter+1;
    disp("MPC Loop Number")
    disp(mpc_iter)
    disp("Current Pose of B")
    disp(mpc_results.state(1:3, end))

    timeReport.contGen_inLoops=[timeReport.contGen_inLoops, toc];   % End NPP solution timer

    if mpc_iter>=1000
        break
    end
    % ---------------------------------------------------------------------
end

%% 6. Post Processing of Data
run('multi_mpc_robots.m')

%% 7. Presentation of Results
run('multi_mpc_showresults.m');

%% Functions

% Function for MPC Termination Conditions
function results=mpcTermination(x, user)

if norm(x(1:2)-user.pose_fnal(1:2))<0.2 ...
        && abs((rem(x(3)+pi(), pi())-pi())-user.pose_fnal(3))<Inf
    results=true;   % Terminate if true
else
    results=false;
end

end

